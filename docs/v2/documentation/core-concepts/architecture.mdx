---
title: "Architecture & Intuition"
description: "Understanding Honcho's core concepts and data model."
icon: "sitemap"
sidebarTitle: "Architecture"
---

<Note> The goal of this page is to build an intuition for the primitives in Honcho and how they fit together </Note>

Honcho has 3 main components that work together to manage agent identity and context. 

- **The Storage API** : The Memory layer for storing interaction history for your agents
- **The Deriver** : The background processing layer that builds representations of users and agents
- **The Dialectic API** : The natural language API for chatting with representations

Below we'll deep dive into these different areas discussing the data
primitives, the flow of data through the system, artifacts honcho produces, and
how to use them.


## Data Model

Honcho has a hiearchal data model centered around the entities below. 

```
Workspaces
├── Peers ←──────────────────┐
│   ├── Sessions             │
│   ├── Collections          │
│   │   └── Documents        │
│   └── Messages (peer-level)│
│                            │
└── Sessions ←───────────────┤ (many-to-many)
    ├── Peers ───────────────┘
    └── Messages (session-level)
```

### <Icon icon="building" /> Workspaces

Workspaces are the top-level containers that provide complete isolation between different applications or environments. Essentially just a namespace to isolate different workloads or environments

**Key Features:**
- **Isolation**: Complete data separation between workspaces
- **Multi-tenancy**: Support multiple applications or environments  
- **Configuration**: Workspace-level settings and metadata
- **Access Control**: Authentication scoped to workspace level

**Use Cases:**
- Separate development/staging/production environments
- Multi-tenant SaaS applications
- Different product lines or use cases
- Complete data separation between teams

---

### <Icon icon="user" /> Peers

Peers are the most important entity within Honcho. Honcho itself could be considered to have a Peer-Centric architecture. 

Peers represent individual users, agents, or entities in a workspace. They are
the primary subjects for memory and context management. Treating humans and
agents the same let's us support arbitrary combinations of Peers for
multi-agent or group chat scenarios.

**Key Features:**
- **Identity**: Unique identifier within a workspace
- **Memory Storage**: Personal memory and context accumulation
- **Configuration**: Per-peer behavioral settings
- **Cross-Session Context**: Memory persists across all sessions

**Use Cases:**
- Individual users in chatbot applications
- AI agents interacting with users or other agents
- Customer profiles in support systems
- Student profiles in educational platforms
- NPCs in role-playing games

---

### <Icon icon="message" /> Sessions

Sessions represent individual conversation threads or interaction contexts between peers.

**Key Features:**
- **Multi-Peer**: Support multiple peers in a single session
- **Temporal Boundaries**: Clear start/end to conversation threads
- **Context Scoping**: Session-specific memory and context
- **Configuration**: Session-level behavioral controls

**Use Cases:**
- Individual chat conversations
- Support tickets
- Meeting transcripts
- Learning sessions

---

### <Icon icon="envelope" /> Messages

Messages are the fundamental units of interaction within sessions. They may
also be used at the peer level to represent stored information of any kind that is not related to a specific interaction, but provides
important context for a peer.

**Key Features:** 
- **Rich Content**: Support for text, metadata, and structured data
- **Attribution**: Clear association with sending peer
- **Ordering**: Chronological sequence within sessions
- **Processing**: Automatic background analysis and insight derivation

**Message Types:**
- User messages
- AI responses
- System notifications
- Rich media content
- User actions (clicked, reacted, etc.)


## Deriver

At the core of developing representations of Peers we have the deriver. The
deriver refers to a set of processes in honcho that enqueues new messages sent
by peers and reasons against them to extract facts, insights, and context.

Depending on the configuration of a `Peer` or `Session` the deriver will behave
differently and update different representations.

Facts derived here are used in the Dialectic chat endpoint to generate
context-aware responses that can correctly reference both concrete facts
extracted from messages and social insights deduced from facts, tone, and
opinion.  

<Info>
Deriver tasks are processed in parallel, but tasks affecting the same peer representation will always be processed serially in order of message creation, so as to properly understand their cumulative effect.
</Info>

There are two types of tasks that the deriver currently does:

- **Representation Tasks**: Generate peer representations
- **Summary Tasks**: Generate conversation summaries

### Peer Representations

Peer representations are more of an abstract concept as they are made up of
various different pieces of data stored throughout Honcho. There are however
multiple types of representations that Honcho can produce. 

Honcho handles both **local** and **global** representations of Peers, where
**local** representations are specific to a single Peer's view of another Peer,
while Global Representations are based on any message ever produced by a Peer. 

This is a key aspect of imbuing your agents with social cognition. There should
be a representation of your agent, but it should also form a representation of
every entity it interacts with. 

More tangibly in an example scenario, if we have a session with 3 particpants Alice, Bob, and Nico, then each of those Peers will have a **local** representation of Bob


### Summary

Summary tasks create conversation summaries and key insights. Periodically, a
"short" summary will be created for each session as messages are added -- every
20 messages by default. "Long" summaries are created every 60 messages by
default and maintain a total overview of the session by including the previous
summary in a recursive fashion. These summaries are accessed in the
`get_context` endpoint along with recent messages, allowing developers to
easily fetch everything necessary to generate the next LLM completion for an
agent.

## Dialectic Chat

Honcho's killer feature is the `chat` endpoint. By storing messages in Honcho, you may query in natural language to get intelligent answer's about a user or agent's personality, theory of mind, history, and more. Dialectic Chat should be thought of as an assisting agent which your agent can reach out to for useful context and answers about actors, human or AI, operating your application.

<Note>
Think of Dialectic Chat as an assisting agent that your main agent can consult for contextual information about any actor in your application.
</Note>

## Scalability Considerations

- **Stateless API**: Scale API servers independently
- **Queue Workers**: Scale background processing workers
- **Database**: PostgreSQL with read replicas

## Security Architecture

- **JWTs**: Secure API access
- **Scoped Access**: Workspace/peer/session level permissions
- **Admin Controls**: Super-user capabilities
- **Workspace Isolation**: Complete data separation
- **Encryption**: Data encryption at rest and in transit

## Next Steps

<CardGroup cols={2}>
  <Card title="Platform SDK" icon="code" href="/v2/documentation/platform/sdk">
    Learn how to use the SDK to interact with the data model
  </Card>
  <Card title="Glossary" icon="book" href="/v2/documentation/core-concepts/glossary">
    Reference for all technical terms and concepts
  </Card>
  <Card title="API Reference" icon="api" href="/v2/api-reference/introduction">
    Detailed API documentation and examples
  </Card>
  <Card title="Quick Start" icon="rocket" href="/v2/documentation/introduction/quickstart">
    Get started with your first integration
  </Card>
</CardGroup>
