"""Predictions router for read-only access to prediction artifacts.

This module provides GET and search endpoints for querying predictions generated
during reasoning dreams. Predictions are created exclusively by the Predictor
agent and cannot be created or modified via the API.
"""

import logging

from fastapi import APIRouter, Body, Depends, HTTPException, Path, Query
from fastapi_pagination import Page
from fastapi_pagination.ext.sqlalchemy import apaginate
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from src import crud, models, schemas
from src.dependencies import db
from src.security import require_auth

logger = logging.getLogger(__name__)

router = APIRouter(
    prefix="/workspaces/{workspace_id}/predictions",
    tags=["reasoning"],
    responses={
        404: {"description": "Workspace or prediction not found"},
        401: {"description": "Unauthorized - invalid or missing authentication"},
    },
)


@router.get(
    "",
    response_model=Page[schemas.PredictionResponse],
    dependencies=[Depends(require_auth(workspace_name="workspace_id"))],
)
async def list_predictions(
    workspace_id: str = Path(..., description="Workspace ID"),
    hypothesis_id: str | None = Query(None, description="Filter by hypothesis ID"),
    status: str | None = Query(
        None, description="Filter by status (untested/unfalsified/falsified)"
    ),
    is_blind: bool | None = Query(None, description="Filter by blind prediction flag"),
    db: AsyncSession = db,
):
    """
    List all predictions for a workspace with optional filters.

    Predictions are testable claims generated by the Predictor agent from
    hypotheses during reasoning dreams. They are subsequently tested by the
    Falsifier agent.

    Query Parameters:
    - hypothesis_id: Filter by source hypothesis
    - status: Filter by prediction status
    - is_blind: Filter by whether prediction was made blindly (before seeing evidence)
    """
    stmt = select(models.Prediction).where(
        models.Prediction.workspace_name == workspace_id
    )

    if hypothesis_id:
        stmt = stmt.where(models.Prediction.hypothesis_id == hypothesis_id)
    if status:
        stmt = stmt.where(models.Prediction.status == status)
    if is_blind is not None:
        stmt = stmt.where(models.Prediction.is_blind == is_blind)

    stmt = stmt.order_by(models.Prediction.created_at.desc())

    return await apaginate(db, stmt)


@router.get(
    "/{prediction_id}",
    response_model=schemas.PredictionResponse,
    dependencies=[Depends(require_auth(workspace_name="workspace_id"))],
)
async def get_prediction(
    workspace_id: str = Path(..., description="Workspace ID"),
    prediction_id: str = Path(..., description="Prediction ID"),
    db: AsyncSession = db,
):
    """
    Get a specific prediction by ID.

    Returns detailed information about a single prediction including its
    content, status, hypothesis association, and whether it was a blind prediction.
    """
    prediction = await crud.prediction.get_prediction(
        db, workspace_name=workspace_id, prediction_id=prediction_id
    )

    if not prediction:
        raise HTTPException(
            status_code=404, detail=f"Prediction {prediction_id} not found"
        )

    return prediction


@router.post(
    "/search",
    response_model=Page[schemas.PredictionResponse],
    dependencies=[Depends(require_auth(workspace_name="workspace_id"))],
)
async def search_predictions(
    workspace_id: str = Path(..., description="Workspace ID"),
    query: str = Body(..., embed=True, description="Search query text"),
    hypothesis_id: str | None = Body(None, description="Filter by hypothesis ID"),
    db: AsyncSession = db,
):
    """
    Semantic search for similar predictions.

    Performs vector similarity search to find predictions semantically similar
    to the query text. This is useful for finding related predictions or checking
    if a prediction has already been made.

    Request Body:
    - query: The text to search for semantically similar predictions
    - hypothesis_id: Optional filter by source hypothesis
    """
    # Get search results from CRUD
    predictions = await crud.prediction.search_predictions(
        db,
        workspace_name=workspace_id,
        query=query,
        hypothesis_id=hypothesis_id,
        limit=50,
    )

    # Convert to Page response
    return {"items": predictions, "total": len(predictions)}


@router.get(
    "/{prediction_id}/traces",
    response_model=Page[schemas.TraceResponse],
    dependencies=[Depends(require_auth(workspace_name="workspace_id"))],
)
async def get_prediction_traces(
    workspace_id: str = Path(..., description="Workspace ID"),
    prediction_id: str = Path(..., description="Prediction ID"),
    db: AsyncSession = db,
):
    """
    List all falsification traces for a specific prediction.

    Falsification traces record the Falsifier agent's attempts to find
    contradictory evidence for the prediction. Each trace includes search
    queries, contradicting premises found, and reasoning chains.

    Multiple traces can exist for a prediction if it was retested.
    """
    # Verify prediction exists
    prediction = await crud.prediction.get_prediction(
        db, workspace_name=workspace_id, prediction_id=prediction_id
    )
    if not prediction:
        raise HTTPException(
            status_code=404, detail=f"Prediction {prediction_id} not found"
        )

    stmt = select(models.FalsificationTrace).where(
        models.FalsificationTrace.workspace_name == workspace_id,
        models.FalsificationTrace.prediction_id == prediction_id,
    )

    stmt = stmt.order_by(models.FalsificationTrace.created_at.desc())

    return await apaginate(db, stmt)
