"""Hypotheses router for read-only access to reasoning artifacts.

This module provides GET-only endpoints for querying hypotheses generated
during reasoning dreams. Hypotheses are created exclusively by the Abducer
agent during dream processing and cannot be created or modified via the API.
"""

import logging

from fastapi import APIRouter, Depends, HTTPException, Path, Query
from fastapi_pagination import Page
from fastapi_pagination.ext.sqlalchemy import apaginate
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from src import crud, models, schemas
from src.dependencies import db
from src.security import require_auth

logger = logging.getLogger(__name__)

router = APIRouter(
    prefix="/workspaces/{workspace_id}/hypotheses",
    tags=["reasoning"],
    responses={
        404: {"description": "Workspace or hypothesis not found"},
        401: {"description": "Unauthorized - invalid or missing authentication"},
    },
)


@router.get(
    "",
    response_model=Page[schemas.HypothesisResponse],
    dependencies=[Depends(require_auth(workspace_name="workspace_id"))],
    summary="List hypotheses",
    description="""
List all hypotheses for a workspace with optional filters.

Hypotheses are explanatory theories generated by the Abducer agent during
reasoning dreams. They are created from accumulated observations and evolve
over time as new evidence emerges through the prediction-falsification cycle.

**Authentication:** Requires workspace-scoped authentication.

**Pagination:** Returns paginated results. Use `page` and `size` query parameters
to navigate through results.
    """,
    responses={
        200: {
            "description": "Successfully retrieved hypotheses",
            "content": {
                "application/json": {
                    "example": {
                        "items": [
                            {
                                "id": "hyp_abc123",
                                "workspace_name": "workspace-1",
                                "observer": "assistant",
                                "observed": "user-123",
                                "content": "User prefers concise responses over detailed explanations",
                                "confidence_score": 0.75,
                                "tier": 2,
                                "status": "active",
                                "source_premise_ids": ["obs_1", "obs_2", "obs_3"],
                                "reasoning_metadata": {"source_count": 3},
                                "created_at": "2024-01-15T10:30:00Z",
                                "updated_at": "2024-01-15T10:30:00Z",
                            }
                        ],
                        "total": 1,
                        "page": 1,
                        "size": 50,
                        "pages": 1,
                    }
                }
            },
        }
    },
)
async def list_hypotheses(
    workspace_id: str = Path(..., description="Workspace ID"),
    observer: str | None = Query(
        None, description="Filter by observer peer ID (who made the observations)"
    ),
    observed: str | None = Query(
        None, description="Filter by observed peer ID (who is being observed)"
    ),
    status: str | None = Query(
        None,
        description="Filter by hypothesis status",
        enum=["active", "superseded", "falsified"],
    ),
    tier: int | None = Query(
        None,
        description="Filter by confidence tier (1=exploratory, 2=working, 3=candidate)",
        ge=1,
        le=3,
    ),
    db: AsyncSession = db,
):
    """List hypotheses with filtering and pagination."""
    stmt = select(models.Hypothesis).where(
        models.Hypothesis.workspace_name == workspace_id
    )

    if observer:
        stmt = stmt.where(models.Hypothesis.observer == observer)
    if observed:
        stmt = stmt.where(models.Hypothesis.observed == observed)
    if status:
        stmt = stmt.where(models.Hypothesis.status == status)
    if tier is not None:
        stmt = stmt.where(models.Hypothesis.tier == tier)

    stmt = stmt.order_by(models.Hypothesis.created_at.desc())

    return await apaginate(db, stmt)


@router.get(
    "/{hypothesis_id}",
    response_model=schemas.HypothesisResponse,
    dependencies=[Depends(require_auth(workspace_name="workspace_id"))],
)
async def get_hypothesis(
    workspace_id: str = Path(..., description="Workspace ID"),
    hypothesis_id: str = Path(..., description="Hypothesis ID"),
    db: AsyncSession = db,
):
    """
    Get a specific hypothesis by ID.

    Returns detailed information about a single hypothesis including its
    content, confidence score, tier, status, and creation metadata.
    """
    hypothesis = await crud.hypothesis.get_hypothesis(
        db, workspace_name=workspace_id, hypothesis_id=hypothesis_id
    )

    if not hypothesis:
        raise HTTPException(
            status_code=404, detail=f"Hypothesis {hypothesis_id} not found"
        )

    return hypothesis


@router.get(
    "/{hypothesis_id}/predictions",
    response_model=Page[schemas.PredictionResponse],
    dependencies=[Depends(require_auth(workspace_name="workspace_id"))],
)
async def get_hypothesis_predictions(
    workspace_id: str = Path(..., description="Workspace ID"),
    hypothesis_id: str = Path(..., description="Hypothesis ID"),
    status: str | None = Query(
        None, description="Filter by prediction status (untested/unfalsified/falsified)"
    ),
    db: AsyncSession = db,
):
    """
    List all predictions derived from a specific hypothesis.

    Predictions are testable claims generated by the Predictor agent from
    a hypothesis. They are subsequently tested by the Falsifier agent to
    determine if they hold true against the evidence.

    Query Parameters:
    - status: Filter by prediction status (untested, unfalsified, falsified)
    """
    # Verify hypothesis exists
    hypothesis = await crud.hypothesis.get_hypothesis(
        db, workspace_name=workspace_id, hypothesis_id=hypothesis_id
    )
    if not hypothesis:
        raise HTTPException(
            status_code=404, detail=f"Hypothesis {hypothesis_id} not found"
        )

    stmt = select(models.Prediction).where(
        models.Prediction.workspace_name == workspace_id,
        models.Prediction.hypothesis_id == hypothesis_id,
    )

    if status:
        stmt = stmt.where(models.Prediction.status == status)

    stmt = stmt.order_by(models.Prediction.created_at.desc())

    return await apaginate(db, stmt)


@router.get(
    "/{hypothesis_id}/genealogy",
    response_model=schemas.HypothesisGenealogy,
    dependencies=[Depends(require_auth(workspace_name="workspace_id"))],
)
async def get_hypothesis_genealogy(
    workspace_id: str = Path(..., description="Workspace ID"),
    hypothesis_id: str = Path(..., description="Hypothesis ID"),
    db: AsyncSession = db,
):
    """
    Get the evolution tree for a hypothesis.

    Returns the genealogy showing how this hypothesis evolved, including:
    - Parent hypotheses that this superseded or was derived from
    - Child hypotheses that superseded or were derived from this one
    - Reasoning metadata explaining the evolution

    This helps track how the agent's understanding evolved over time.
    """
    hypothesis = await crud.hypothesis.get_hypothesis(
        db, workspace_name=workspace_id, hypothesis_id=hypothesis_id
    )
    if not hypothesis:
        raise HTTPException(
            status_code=404, detail=f"Hypothesis {hypothesis_id} not found"
        )

    # Get parent hypotheses (what this superseded)
    parent_ids = hypothesis.reasoning_metadata.get("supersedes", [])
    parents = []
    if parent_ids:
        parent_stmt = select(models.Hypothesis).where(
            models.Hypothesis.workspace_name == workspace_id,
            models.Hypothesis.id.in_(parent_ids),
        )
        parent_result = await db.execute(parent_stmt)
        parents = list(parent_result.scalars().all())

    # Get child hypotheses (what superseded this)
    child_stmt = select(models.Hypothesis).where(
        models.Hypothesis.workspace_name == workspace_id,
        models.Hypothesis.reasoning_metadata["supersedes"]
        .as_string()
        .contains(hypothesis_id),
    )
    child_result = await db.execute(child_stmt)
    children = list(child_result.scalars().all())

    return {
        "hypothesis": hypothesis,
        "parents": parents,
        "children": children,
        "reasoning_metadata": hypothesis.reasoning_metadata,
    }
